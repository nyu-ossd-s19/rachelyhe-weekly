---
layout: post
title: Week 8
---

## Readings
* [Producing Open Source Software](http://producingoss.com/) by Karl Fogel
* [Cathedral and the Bazaar](http://www.catb.org/~esr/writings/cathedral-bazaar/) by Eric S. Raymond
* [Why Open Source Misses the Point of Free Software](http://www.gnu.org/philosophy/open-source-misses-the-point.html) by Richard Stallman

### Software Development: Cathedral vs. Bazaar Model
*Cathedral and the Bazaar by Eric S. Raymond*

The premise of the cathedral model for software development is that the software is carefully built by the developers (either individual or in a small group) in isolation, releasing its first iteration without a beta or being seen by the public eye. The bazaar model, on the other hand, takes in the "differing agendas and approaches". Raymond gives the example of the Lunix archive sites that take open submissions from anyone. 

Raymond states that he is initially baffled by the success of the bazaar model, and that organized systems within "bazaar" software seemed to appear from miracles. Ultimately, from what *seems* to succeed, many software developers have decided that adopting either model to the extreme means that the software is likely to come out heavily flawed — the "cathedral" projects now often have beta releases or conduct broader user testing, and the "bazaar" projects are often regulated (or contributors are vetted).

Personally, my only strong stance on entering a professional project is that the people who are contributing to the project are ethical and qualified (professionally experienced and / or technically proficient) in their contributions. This generally means that the cathedral model is more fitted to my liking, but I also find I can enjoy projects adopting the bazaar model if the contributors have some expertise in the subject and also seem really motivated to make the product great. 

### 19 Lessons
Of the 19 lessons in *The Cathedral and The Bazaar*, these are the two I found most interesting:

**Lesson 2: "Good programmers know what to write. Great ones know what to rewrite (and reuse)."**
This lesson has been on my mind for quite some time — "remixing" content has long been a tricky subject when it comes to content creation. David Shields wrote [“I Can’t Stop Thinking Through What Other People Are Thinking”](http://www.thewhitereview.org/feature/i-cant-stop-thinking-through-what-other-people-are-thinking/) to try to dissect rewriting / reusing content in art — in his case, the focus is on writing and music. He outlines the universal rules of copyright in these disciplines, plain and simple:

“There are three crucial terms when it comes to copyright: fair use – you can quote 10 per cent or less of a book, or 250 words or fewer from a shorter work; public domain – you can quote from Kipling, since he’s been dead for more than seventy-five years; and, most importantly, transformation – in your appropriation of another work, are you simply plagiarising, or are you remaking it?”

Ultimately, there is great gain in being able to remix or reuse content. Students can remix work to tinker with something complex, without having the years of professional experience required to build it from scratch. Programmers can take the skeleton structure of a program and repurpose it for something completely different. Great software models can be given homage through nostalgic references or clever attribution. Linus Torvalds reusing Minix's code gave a vital structural foundation to something that ultimately became completely clean of borrowed code. As Raymond aptly states, it was merely "scaffolding".

**Lesson 5: "When you lose interest in a program, your last duty to it is to hand it off to a competent successor."**
Handoff can be particularly tricky when the creator (or any programmer) loses interest in a program. Each programmer likely has a graveyard of ideas that started with an excited burst of inspiration and ended oh-so-quickly as they realized that the cost was too much, or that it would require more time than the programmer was willing to invest, or even that the "timing wasn't quite right". 

Handing off a project to someone else also requires great deliberation: will this person drive the project in an ethical direction? Do they have a common idea as to what the project should end up like? Do they uphold the same values as the original creators? I've seen code collect dust in someone's digital basement, only to be handed off to the first person who seems mildly interested in using the code. Raymond is right on the dot with this one — the successor to a program should be chosen with great care. 

##Caprine Progress
Not much happened this week with Caprine. My issue was seen by the creator and tagged with the appropriate tags. Because I noted that I'd be interested in working on the issue, it seems that no one else is likely to hop on the problem just yet. 

Currently, my team is trying to reach out to the creator / maintainers of the repository to see what we can do to properly establish a good communication channel between all of the contributors. 

We learned that it might be best to reach out to the creator / maintainers now, as we have successfully submitted an issue report and have established some level of interest in contributing to the project. We considered contacting the creator through his social channels, but it seems that commenting directly on the issue report might have greater success, as the request can be recorded for the entire community to see and respond to.
